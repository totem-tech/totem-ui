"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DigestItem = exports.PreRuntime = exports.Other = exports.Seal = exports.SealV0 = exports.Consensus = exports.ConsensusEngineId = exports.ChangesTrieRoot = exports.AuthoritiesChange = exports.CID_GRPA = exports.CID_BABE = exports.CID_AURA = void 0;

var _util = require("@polkadot/util");

var _Enum = _interopRequireDefault(require("../codec/Enum"));

var _Struct = _interopRequireDefault(require("../codec/Struct"));

var _Tuple = _interopRequireDefault(require("../codec/Tuple"));

var _Vector = _interopRequireDefault(require("../codec/Vector"));

var _Bytes = _interopRequireDefault(require("../primitive/Bytes"));

var _Hash = _interopRequireDefault(require("../primitive/Hash"));

var _U = _interopRequireDefault(require("../primitive/U32"));

var _U2 = _interopRequireDefault(require("../primitive/U64"));

var _AuthorityId = _interopRequireDefault(require("../type/AuthorityId"));

var _Signature = _interopRequireDefault(require("../type/Signature"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const CID_AURA = 0x61727561; // 'aura'

exports.CID_AURA = CID_AURA;
const CID_BABE = 0x65626162; // 'babe'

exports.CID_BABE = CID_BABE;
const CID_GRPA = 0x31676661; // 'afg1'

exports.CID_GRPA = CID_GRPA;

/**
 * @name AuthoritiesChange
 * @description
 * Log for Authories changed
 */
class AuthoritiesChange extends _Vector.default.with(_AuthorityId.default) {}
/**
 * @name ChangesTrieRoot
 * @description
 * Log for changes to the Trie root
 */


exports.AuthoritiesChange = AuthoritiesChange;

class ChangesTrieRoot extends _Hash.default {}
/**
 * @name ConsensusEngineId
 * @description
 * A 4-byte identifier (actually a [u8; 4]) identifying the engine, e.g. for Aura it would be [b'a', b'u', b'r', b'a']
 */


exports.ChangesTrieRoot = ChangesTrieRoot;

class ConsensusEngineId extends _U.default {
  static idToString(input) {
    return (0, _util.bnToBn)(input).toArray('le').map(code => String.fromCharCode(code)).join('');
  }

  static stringToId(input) {
    return input.split('').reverse().reduce((result, char) => result * 256 + char.charCodeAt(0), 0);
  }
  /**
   * @description `true` if the engine matches aura
   */


  get isAura() {
    return this.eq(CID_AURA);
  }
  /**
   * @description `true` is the engine matches babe
   */


  get isBabe() {
    return this.eq(CID_BABE);
  }
  /**
   * @description `true` is the engine matches grandpa
   */


  get isGrandpa() {
    return this.eq(CID_GRPA);
  }
  /**
   * @description From the input bytes, decode into an aura-tuple
   */


  extractSlot(bytes) {
    (0, _util.assert)(this.isAura, 'Invalid engine for asAura conversion');
    return new _U2.default( // no compact prefix, only use the correct number of supplied bytes
    bytes.toU8a(true).subarray(0, 8));
  }
  /**
   * @description Override the default toString to return a 4-byte string
   */


  toString() {
    return ConsensusEngineId.idToString(this);
  }

}
/**
 * @name Consensus
 * @description
 * Log item indicating consensus
 */


exports.ConsensusEngineId = ConsensusEngineId;

class Consensus extends _Tuple.default {
  constructor(value) {
    super({
      ConsensusEngineId,
      Bytes: _Bytes.default
    }, value);
  }
  /**
   * @description The wrapped engine [[ConsensusEngineId]]
   */


  get engine() {
    return this[0];
  }
  /**
   * @description The wrapped [[Bytes]]
   */


  get data() {
    return this[1];
  }
  /**
   * @description The slot extracted from the raw data (fails on non-Aura)
   */


  get slot() {
    return this.engine.extractSlot(this.data);
  }

}
/**
 * @name SealV0
 * @description
 * Log item indicating a sealing event. This has been replaced in later versions with a renamed [[Seal]], we however have kept compatibility with the old version
 */


exports.Consensus = Consensus;

class SealV0 extends _Tuple.default {
  constructor(value) {
    super({
      U64: _U2.default,
      Signature: _Signature.default
    }, value);
  }
  /**
   * @description The wrapped [[Signature]]
   */


  get signature() {
    return this[1];
  }
  /**
   * @description The wrapped [[U64]] slot
   */


  get slot() {
    return this[0];
  }

}
/**
 * @name Seal
 * @description
 * Log item indicating a sealing event.
 */


exports.SealV0 = SealV0;

class Seal extends _Tuple.default {
  constructor(value) {
    super({
      ConsensusEngineId,
      Signature: _Signature.default
    }, value);
  }
  /**
   * @description The wrapped [[Signature]]
   */


  get signature() {
    return this[1];
  }
  /**
   * @description The wrapped [[U64]] slot
   */


  get slot() {
    return this[0];
  }

}
/**
 * @name Other
 * @description
 * Log item that is just a stream of [[Bytes]]
 */


exports.Seal = Seal;

class Other extends _Bytes.default {}
/**
 * @name PreRuntime
 * @description
 * These are messages from the consensus engine to the runtime, although the consensus engine the consensus engine can (and should) read them itself to avoid ode and state duplication.
 */


exports.Other = Other;

class PreRuntime extends _Tuple.default {
  constructor(value) {
    super({
      ConsensusEngineId,
      Bytes: _Bytes.default
    }, value);
  }
  /**
   * @description The wrapped [[ConsensusEngineId]]
   */


  get engine() {
    return this[0];
  }
  /**
   * @description The wrapped [[Bytes]]
   */


  get data() {
    return this[1];
  }
  /**
   * @description The slot extracted from the raw data (fails on non-Aura)
   */


  get slot() {
    return this.engine.extractSlot(this.data);
  }

} // Note the ordering, it aligns with numbers to the Rust implementation
// (current and previous versions are included hjere, e.g. SealV0)


exports.PreRuntime = PreRuntime;
const DigestItemEnumMap = {
  Other,
  // 0
  AuthoritiesChange,
  // 1
  ChangesTrieRoot,
  // 2
  SealV0,
  // 3
  Consensus,
  // 4
  Seal,
  // 5
  PreRuntime // 6

};

/**
 * @name DigestItem
 * @description
 * A [[Enum]] the specifies the specific item in the logs of a [[Digest]]
 */
class DigestItem extends _Enum.default {
  constructor(value) {
    super(DigestItemEnumMap, value);
  }
  /**
   * @description Returns the item as a [[AuthoritiesChange]]
   */


  get asAuthoritiesChange() {
    (0, _util.assert)(this.isAuthoritiesChange, "Cannot convert '".concat(this.type, "' via asAuthoritiesChange"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[ChangesTrieRoot]]
   */


  get asChangesTrieRoot() {
    (0, _util.assert)(this.isChangesTrieRoot, "Cannot convert '".concat(this.type, "' via asChangesTrieRoot"));
    return this.value;
  }
  /**
   * @desciption Retuns the item as a [[Consensus]]
   */


  get asConsensus() {
    (0, _util.assert)(this.isConsensus, "Cannot convert '".concat(this.type, "' via asConsensus"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[Other]]
   */


  get asOther() {
    (0, _util.assert)(this.isOther, "Cannot convert '".concat(this.type, "' via asOther"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[PreRuntime]]
   */


  get asPreRuntime() {
    (0, _util.assert)(this.isPreRuntime, "Cannot convert '".concat(this.type, "' via asPreRuntime"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[Seal]]
   */


  get asSeal() {
    (0, _util.assert)(this.isSeal, "Cannot convert '".concat(this.type, "' via asSeal"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[SealV0]]
   */


  get asSealV0() {
    (0, _util.assert)(this.isSealV0, "Cannot convert '".concat(this.type, "' via asSealV0"));
    return this.value;
  }
  /**
   * @description Returns true on [[AuthoritiesChange]]
   */


  get isAuthoritiesChange() {
    return this.type === 'AuthoritiesChange';
  }
  /**
   * @description Returns true on [[ChangesTrieRoot]]
   */


  get isChangesTrieRoot() {
    return this.type === 'ChangesTrieRoot';
  }
  /**
   * @description Returns true on [[Consensus]]
   */


  get isConsensus() {
    return this.type === 'Consensus';
  }
  /**
   * @description Returns true on [[Other]]
   */


  get isOther() {
    return this.type === 'Other';
  }
  /**
   * @description Returns true on [[PreRuntime]]
   */


  get isPreRuntime() {
    return this.type === 'PreRuntime';
  }
  /**
   * @description Returns true on [[Seal]]
   */


  get isSeal() {
    return this.type === 'Seal';
  }
  /**
   * @description Returns true on [[SealV0]]
   */


  get isSealV0() {
    return this.type === 'SealV0';
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers. For logs, we overrides to produce the hex version (sligning with substrate gives in actual JSON responses)
   */


  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the type of engine, we just override here to get the typings correct
   */


  get type() {
    return super.type;
  }

}
/**
 * @name Digest
 * @description
 * A [[Header]] Digest
 */


exports.DigestItem = DigestItem;

class Digest extends _Struct.default {
  constructor(value) {
    super({
      logs: _Vector.default.with(DigestItem)
    }, value);
  }
  /**
   * @description The [[DigestItem]] logs
   */


  get logs() {
    return this.get('logs');
  }
  /**
   * @description The [[DigestItem]] logs, filtered, filter items included. This is useful for derive functionality where only a certain type of log is to be returned.
   */


  logsWith() {
    for (var _len = arguments.length, include = new Array(_len), _key = 0; _key < _len; _key++) {
      include[_key] = arguments[_key];
    }

    return this.logs.filter((_ref) => {
      let {
        type
      } = _ref;
      return include.includes(type);
    });
  }
  /**
   * @description The [[DigestItem]] logs, filtered, filter items exluded. This is useful for stripping headers for eg. WASM runtime execution.
   */


  logsWithout() {
    for (var _len2 = arguments.length, exclude = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      exclude[_key2] = arguments[_key2];
    }

    return this.logs.filter((_ref2) => {
      let {
        type
      } = _ref2;
      return !exclude.includes(type);
    });
  }

}

exports.default = Digest;