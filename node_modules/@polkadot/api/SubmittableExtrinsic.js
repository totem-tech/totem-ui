"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSubmittableExtrinsic;
exports.SubmittableResult = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _types = require("@polkadot/types");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _util = require("@polkadot/util");

var _filterEvents = _interopRequireDefault(require("./util/filterEvents"));

// Copyright 2017-2019 @polkadot/api authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
class SubmittableResult extends _types.Struct {
  constructor(value) {
    super({
      events: _types.Vector.with(_types.EventRecord),
      status: _types.ExtrinsicStatus
    }, value);
  }
  /**
   * @description the contained events
   */


  get events() {
    return this.get('events');
  }
  /**
   * @description the status
   */


  get status() {
    return this.get('status');
  }
  /**
   * @description Finds an EventRecord for the specified method & section
   */


  findRecord(section, method) {
    return this.events.find((_ref) => {
      let {
        event
      } = _ref;
      return event.section === section && event.method === method;
    });
  }

}

exports.SubmittableResult = SubmittableResult;

function createSubmittableExtrinsic(type, api, onCall, extrinsic, trackingCb) {
  const _extrinsic = new ((0, _types.getTypeRegistry)().getOrThrow('Extrinsic'))(extrinsic);

  const _noStatusCb = type === 'rxjs';

  function updateSigner(updateId, status) {
    if (updateId !== -1 && api.signer && api.signer.update) {
      api.signer.update(updateId, status);
    }
  }

  function statusObservable(status) {
    if (!status.isFinalized) {
      const result = new SubmittableResult({
        status
      });
      trackingCb && trackingCb(result);
      return (0, _rxjs.of)(result);
    }

    const blockHash = status.asFinalized;
    return (0, _rxjs.combineLatest)([api.rpc.chain.getBlock(blockHash), api.query.system.events.at(blockHash)]).pipe((0, _operators.map)((_ref2) => {
      let [signedBlock, allEvents] = _ref2;
      const result = new SubmittableResult({
        events: (0, _filterEvents.default)(_extrinsic.hash, signedBlock, allEvents),
        status
      });
      trackingCb && trackingCb(result);
      return result;
    }));
  }

  function sendObservable() {
    let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    return api.rpc.author.submitExtrinsic(_extrinsic).pipe((0, _operators.tap)(hash => {
      updateSigner(updateId, hash);
    }));
  }

  function subscribeObservable() {
    let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    return api.rpc.author.submitAndWatchExtrinsic(_extrinsic).pipe((0, _operators.switchMap)(status => statusObservable(status)), (0, _operators.tap)(status => {
      updateSigner(updateId, status);
    }));
  }

  function expandOptions(options) {
    return (0, _objectSpread2.default)({
      blockHash: api.genesisHash,
      version: api.runtimeVersion
    }, options);
  }

  const signOrigin = _extrinsic.sign;
  Object.defineProperties(_extrinsic, {
    send: {
      value: function value(statusCb) {
        const isSubscription = _noStatusCb || !!statusCb;
        return onCall(() => isSubscription ? subscribeObservable() : sendObservable(), [], statusCb, isSubscription);
      }
    },
    sign: {
      value: function value(account, _options) {
        // HACK here we actually override nonce if it was specified (backwards compat for
        // the previous signature - don't let userspace break, but allow then time to upgrade)
        const options = (0, _util.isBn)(_options) || (0, _util.isNumber)(_options) ? {
          nonce: _options
        } : _options;
        signOrigin.apply(_extrinsic, [account, expandOptions(options)]);
        return this;
      }
    },
    signAndSend: {
      value: function value(account, _options, statusCb) {
        let options = {};

        if ((0, _util.isFunction)(_options)) {
          statusCb = _options;
        } else {
          options = _options || {};
        }

        const isSubscription = _noStatusCb || !!statusCb;
        const isKeyringPair = (0, _util.isFunction)(account.sign);
        const address = isKeyringPair ? account.address : account.toString();
        let updateId;
        return onCall(() => ((0, _util.isUndefined)(options.nonce) ? api.query.system.accountNonce(address) : (0, _rxjs.of)(new _types.Index(options.nonce))).pipe((0, _operators.first)(), (0, _operators.mergeMap)(async nonce => {
          if (isKeyringPair) {
            this.sign(account, (0, _objectSpread2.default)({}, options, {
              nonce
            }));
          } else {
            (0, _util.assert)(api.signer, 'no signer exists');
            updateId = await api.signer.sign(_extrinsic, address, (0, _objectSpread2.default)({}, expandOptions((0, _objectSpread2.default)({}, options, {
              nonce
            })), {
              genesisHash: api.genesisHash
            }));
          }
        }), (0, _operators.switchMap)(() => {
          return isSubscription ? subscribeObservable(updateId) : sendObservable(updateId); // ???
        })), [], statusCb, isSubscription);
      }
    }
  });
  return _extrinsic;
}