import BN from 'bn.js';
import U8a from './codec/U8a';
import { FunctionMetadata } from './Metadata/v5/Calls';
import Method from './primitive/Method';
import Address from './primitive/Address';
export declare type IKeyringPair = {
    address: string;
    publicKey: Uint8Array;
    sign: (data: Uint8Array) => Uint8Array;
};
export declare type CodecArg = Codec | BN | Boolean | String | Uint8Array | boolean | number | string | undefined | CodecArgArray | CodecArgObject;
export declare type CodecCallback<T extends Codec = any> = (result: T) => any;
interface CodecArgObject {
    [index: string]: CodecArg;
}
interface CodecArgArray extends Array<CodecArg> {
}
export declare type AnyNumber = BN | Uint8Array | number | string;
export declare type AnyString = string | String;
export declare type AnyU8a = Uint8Array | Array<number> | string;
/**
 * @name Codec
 * @description
 * The base Codec interface. All types implement the interface provided here. Additionally
 * implementors can add their own specific interfaces and helpres with getters and functions.
 * The Codec Base is however required for operating as an encoding/decoding layer
 */
export interface Codec {
    /**
     * @description The length of the value when encoded as a Uint8Array
     */
    encodedLength: number;
    /**
     * @description Checks if the value is an empty value
     */
    isEmpty: boolean;
    /**
     * @description Compares the value of the input to see if there is a match
     */
    eq(other?: any): boolean;
    /**
     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) repersentation
     */
    toHex(isLe?: boolean): string;
    /**
     * @description Converts the Object to JSON, typically used for RPC transfers
     */
    toJSON(): any;
    /**
     * @description Returns the base runtime type name for this instance
     */
    toRawType(): string;
    /**
     * @description Returns the string representation of the value
     */
    toString(): string;
    /**
     * @description Encodes the value as a Uint8Array as per the SCALE specifications
     * @param isBare true when the value has none of the type-specific prefixes (internal)
     */
    toU8a(isBare?: boolean): Uint8Array;
}
export declare type CodecTo = 'toHex' | 'toJSON' | 'toString' | 'toU8a';
export interface Constructor<T = Codec> {
    Fallback?: Constructor<T>;
    new (...value: Array<any>): T;
}
export declare type ConstructorDef<T = Codec> = {
    [index: string]: Constructor<T>;
};
export declare type TypeDef = {
    [index: string]: Codec;
};
export declare type RegistryTypes = {
    [name: string]: Constructor | string | {
        [name: string]: string;
    };
};
export interface RuntimeVersionInterface {
    readonly apis: Array<any>;
    readonly authoringVersion: BN;
    readonly implName: String;
    readonly implVersion: BN;
    readonly specName: String;
    readonly specVersion: BN;
}
export declare type SignatureOptions = {
    blockHash: AnyU8a;
    era?: Uint8Array;
    nonce: AnyNumber;
    version?: RuntimeVersionInterface;
};
export interface ArgsDef {
    [index: string]: Constructor;
}
export interface IHash extends U8a {
}
export interface IMethod extends Codec {
    readonly args: Array<Codec>;
    readonly argsDef: ArgsDef;
    readonly callIndex: Uint8Array;
    readonly data: Uint8Array;
    readonly hasOrigin: boolean;
    readonly meta: FunctionMetadata;
}
export interface IExtrinsicSignature extends Codec {
    readonly isSigned: boolean;
    era: IExtrinsicEra;
}
export interface IExtrinsicEra {
    asImmortalEra: Codec;
    asMortalEra: Codec;
}
export interface IExtrinsic extends IMethod {
    hash: IHash;
    isSigned: boolean;
    method: Method;
    signature: IExtrinsicSignature;
    addSignature(signer: Address | Uint8Array | string, signature: Uint8Array | string, nonce: AnyNumber, era?: Uint8Array): IExtrinsic;
    sign(account: IKeyringPair, options: SignatureOptions): IExtrinsic;
}
export {};
