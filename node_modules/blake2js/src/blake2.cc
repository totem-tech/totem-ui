#include "blake2.hh"
#include "utils.hh"

namespace B2JS {

using Nan::FunctionCallbackInfo;
using Nan::New;

using v8::Local;
using v8::Number;
using v8::Object;
using v8::Value;

Local<Object> blake2s() {
	return Utils::Wrap<
		blake2s_state,

		blake2s_init,
		blake2s_init_key,
		blake2s_update,
		blake2s_final,

		BLAKE2S_BLOCKBYTES,
		BLAKE2S_OUTBYTES,
		BLAKE2S_KEYBYTES,
		BLAKE2S_SALTBYTES,
		BLAKE2S_PERSONALBYTES
	>();
}

Local<Object> blake2sp() {
	return Utils::Wrap<
		blake2sp_state,

		blake2sp_init,
		blake2sp_init_key,
		blake2sp_update,
		blake2sp_final,

		BLAKE2S_BLOCKBYTES,
		BLAKE2S_OUTBYTES,
		BLAKE2S_KEYBYTES,
		BLAKE2S_SALTBYTES,
		BLAKE2S_PERSONALBYTES
	>();
}

Local<Object> blake2b() {
	return Utils::Wrap<
		blake2b_state,

		blake2b_init,
		blake2b_init_key,
		blake2b_update,
		blake2b_final,

		BLAKE2B_BLOCKBYTES,
		BLAKE2B_OUTBYTES,
		BLAKE2B_KEYBYTES,
		BLAKE2B_SALTBYTES,
		BLAKE2B_PERSONALBYTES
	>();
}

Local<Object> blake2bp() {
	return Utils::Wrap<
		blake2bp_state,

		blake2bp_init,
		blake2bp_init_key,
		blake2bp_update,
		blake2bp_final,

		BLAKE2B_BLOCKBYTES,
		BLAKE2B_OUTBYTES,
		BLAKE2B_KEYBYTES,
		BLAKE2B_SALTBYTES,
		BLAKE2B_PERSONALBYTES
	>();
}


// init(state: Buffer, outlen: Number)
template<typename blake2_state, int (*blake2_init)(blake2_state*, const uint8_t), int OUTBYTES>
void init(const FunctionCallbackInfo<Value>& info) {
	blake2_state* state = Utils::GetState<blake2_state>(info[0]);
	const uint8_t outlen = Utils::Uint8Value(info[1], OUTBYTES);

	if (blake2_init(state, outlen) != 0) {
		Nan::ThrowError("Internal blake2 error!");
	}
}

// init_key(state: Buffer, outlen: Number, key: Buffer)
template<typename blake2_state, int (*blake2_init_key)(blake2_state*, const uint8_t, const void*, const uint8_t), int OUTBYTES, int KEYBYTES>
void init_key(const FunctionCallbackInfo<Value>& info) {
	blake2_state* state = Utils::GetState<blake2_state>(info[0]);
	const uint8_t outlen = Utils::Uint8Value(info[1], OUTBYTES);

	// key
	if (!node::Buffer::HasInstance(info[2])) {
		Nan::ThrowTypeError("The key must be a Buffer!"); }
	if (node::Buffer::Length(info[2]) > KEYBYTES) {
		Nan::ThrowRangeError("Exceeded maximum key lenght!"); }

	const void* key = reinterpret_cast<void*>(node::Buffer::Data(info[2]));
	const uint8_t keylen = node::Buffer::Length(info[2]);

	if (blake2_init_key(state, outlen, key, keylen) != 0) {
		Nan::ThrowError("Internal blake2 error!");
	}
}

// TODO: init_param

// update(state: Buffer, data: Buffer)
template<typename blake2_state, int (*blake2_update)(blake2_state*, const uint8_t*, uint64_t)>
void update(const FunctionCallbackInfo<Value>& info) {
	blake2_state* state = Utils::GetState<blake2_state>(info[0]);

	// data
	if (!node::Buffer::HasInstance(info[1])) {
		Nan::ThrowTypeError("The key must be a Buffer!"); }

	const uint8_t* in = reinterpret_cast<uint8_t*>(node::Buffer::Data(info[1]));
	uint64_t inlen = node::Buffer::Length(info[1]);

	if (blake2_update(state, in, inlen) != 0) {
		Nan::ThrowError("Internal blake2 error!");
	}
}

// final(state: Buffer, outlen: Number)
template<typename blake2_state, int (*blake2_final)(blake2_state*, uint8_t*, uint8_t), int OUTBYTES>
void final(const FunctionCallbackInfo<Value>& info) {
	blake2_state* state = Utils::GetState<blake2_state>(info[0]);
	const uint8_t outlen = Utils::Uint8Value(info[1], OUTBYTES);

	uint8_t* out = new uint8_t[outlen];

	if (blake2_final(state, out, outlen) != 0) {
		Nan::ThrowError("Internal blake2 error!");
	}

	Local<Object> buffer = Nan::CopyBuffer(reinterpret_cast<char*>(out), outlen).ToLocalChecked();

	delete[] out;

	info.GetReturnValue().Set(buffer);
}

} // B2JS
