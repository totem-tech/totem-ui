"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeLatestSubstrate = decodeLatestSubstrate;
exports.toV5 = toV5;
exports.defaultValues = defaultValues;

var _fromMetadata = _interopRequireDefault(require("@polkadot/extrinsics/fromMetadata"));

var _createType = _interopRequireDefault(require("../../codec/createType"));

var _Metadata = _interopRequireDefault(require("../Metadata"));

var _Method = _interopRequireDefault(require("../../primitive/Method"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

/**
 * Given the static `rpcData` and the `latestSubstrate` JSON file, Metadata
 * should decode `rpcData` and output `latestSubstrate`.
 */
function decodeLatestSubstrate(version, rpcData, latestSubstrate) {
  it('decodes latest substrate properly', () => {
    const metadata = new _Metadata.default(rpcData);
    console.error(JSON.stringify(metadata.toJSON()));
    expect(metadata.version).toBe(version);
    expect(metadata["asV".concat(version)].modules.length).not.toBe(0);
    expect(metadata.toJSON()).toEqual(latestSubstrate);
  });
}
/**
 * Given a `version`, MetadataV5 and MetadataV{version} should output the same
 * unique types.
 */


function toV5(version, rpcData) {
  it('converts to V5', () => {
    const metadata = new _Metadata.default(rpcData)["asV".concat(version)];
    const metadataV5 = new _Metadata.default(rpcData).asV5;
    expect(metadata.getUniqTypes(true)).toEqual(metadataV5.getUniqTypes(true));
  });
}
/**
 * Given a Metadata, no type should throw when given its fallback value.
 */


function defaultValues(rpcData) {
  describe('storage with default values', () => {
    const metadata = new _Metadata.default(rpcData);

    _Method.default.injectMethods((0, _fromMetadata.default)(metadata));

    metadata.asV5.modules.filter((_ref) => {
      let {
        storage
      } = _ref;
      return storage.isSome;
    }).map(mod => mod.storage.unwrap().forEach((_ref2) => {
      let {
        fallback,
        name,
        type
      } = _ref2;
      it("creates default types for ".concat(mod.prefix, ".").concat(name, ", type ").concat(type), () => {
        expect(() => (0, _createType.default)(type.toString(), fallback)).not.toThrow();
      });
    }));
  });
}