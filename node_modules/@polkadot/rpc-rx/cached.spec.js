"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _testingPairs = _interopRequireDefault(require("@polkadot/keyring/testingPairs"));

var _types = require("@polkadot/types");

var _ = _interopRequireDefault(require("."));

// Copyright 2017-2019 @polkadot/rpc-rx authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
jest.mock('@polkadot/rpc-provider/ws', () => {
  var _temp;

  return _temp = class {
    constructor() {
      this.isConnected = () => true;

      this.on = () => true;

      this.send = () => true;
    }

  }, _temp;
});
describe('createCachedObservable', () => {
  let api;
  let creator;
  const keyring = (0, _testingPairs.default)();
  let section;
  beforeEach(() => {
    api = new _.default();
  });
  beforeEach(() => {
    // Create two methods in our section
    const subMethod = jest.fn(() => Promise.resolve('subMethodResult'));
    subMethod.unsubscribe = jest.fn(() => Promise.resolve(true));
    const subMethod2 = jest.fn(() => Promise.resolve('subMethod2Result'));
    subMethod2.unsubscribe = jest.fn(() => Promise.resolve(true));
    section = {
      subMethod,
      subMethod2
    }; // @ts-ignore Private method

    creator = api.createObservable('subMethod', section);
  });
  it('creates a single observable', () => {
    creator(123).subscribe();
    expect(section.subMethod).toHaveBeenCalledWith(123, expect.anything());
  });
  it('creates a single observable (multiple calls)', () => {
    const observable1 = creator(123);
    const observable2 = creator(123);
    expect(observable2).toBe(observable1);
  });
  it('creates a single observable (multiple calls, different arguments that should be cached together)', () => {
    const observable1 = creator(keyring.alice.address);
    const observable2 = creator(new _types.AccountId(keyring.alice.address));
    expect(observable2).toBe(observable1);
  });
  it('creates multiple observables for different values', () => {
    const observable1 = creator(123);
    const observable2 = creator(456);
    expect(observable2).not.toBe(observable1);
  });
  it('creates different observables for different methods but same arguments', () => {
    const observable1 = creator(123); // @ts-ignore Private method

    const observable2 = api.createObservable('subMethod2', section)(123);
    expect(observable2).not.toBe(observable1);
  });
});