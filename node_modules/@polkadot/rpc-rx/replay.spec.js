"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _ = _interopRequireDefault(require("."));

// Copyright 2017-2019 @polkadot/rpc-rx authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
jest.mock('@polkadot/rpc-provider/ws', () => {
  var _temp;

  return _temp = class {
    constructor() {
      this.isConnected = () => true;

      this.on = () => true;

      this.send = () => true;
    }

  }, _temp;
});
describe('replay', () => {
  const params = [123, false];
  let api;
  let section;
  let observable;
  let update;
  beforeEach(() => {
    api = new _.default();
  });
  beforeEach(() => {
    const subMethod = jest.fn(function (name) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      update = params.pop();
      return Promise.resolve(12345);
    });
    subMethod.unsubscribe = jest.fn(() => {
      return Promise.resolve(true);
    });
    section = {
      subMethod
    }; // @ts-ignore

    observable = api.createObservable('subMethod', section)(...params);
  });
  it('subscribes via the api section', done => {
    observable.subscribe(value => {
      if (value) {
        expect(section.subMethod).toHaveBeenCalledWith(123, false, expect.anything());
        done();
      }
    });
    update('test');
  });
  it('returns the observable value', done => {
    observable.subscribe(value => {
      if (value) {
        expect(value).toEqual('test');
        done();
      }
    });
    update('test');
  });
  it('unsubscribes as required', done => {
    section.subMethod.unsubscribe = async () => {
      done();
    };

    let subscription = observable.subscribe(value => {
      if (value) {
        subscription.unsubscribe();
      }
    });
    update('test');
  });
});