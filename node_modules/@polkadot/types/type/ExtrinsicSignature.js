"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.IMMORTAL_ERA = void 0;

var _Struct = _interopRequireDefault(require("../codec/Struct"));

var _Address = _interopRequireDefault(require("../primitive/Address"));

var _U = _interopRequireDefault(require("../primitive/U8"));

var _ExtrinsicEra = _interopRequireDefault(require("./ExtrinsicEra"));

var _NonceCompact = _interopRequireDefault(require("./NonceCompact"));

var _Signature = _interopRequireDefault(require("./Signature"));

var _SignaturePayload = _interopRequireDefault(require("./SignaturePayload"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const IMMORTAL_ERA = new Uint8Array([0]);
exports.IMMORTAL_ERA = IMMORTAL_ERA;
const BIT_SIGNED = 0b10000000;
const BIT_UNSIGNED = 0;
const BIT_VERSION = 0b0000001;
/**
 * @name ExtrinsicSignature
 * @description
 * A container for the [[Signature]] associated with a specific [[Extrinsic]]
 */

class ExtrinsicSignature extends _Struct.default {
  // Signature Information.
  //   1 byte version: BIT_VERSION | (isSigned ? BIT_SIGNED : BIT_UNSIGNED)
  //   1/3/5/9/33 bytes: The signing account identity, in Address format
  //   64 bytes: The sr25519/ed25519 signature of the Signing Payload
  //   1-8 bytes: The Compact<Nonce> of the signing account
  //   1/2 bytes: The Transaction Era
  constructor(value) {
    super({
      version: _U.default,
      signer: _Address.default,
      signature: _Signature.default,
      nonce: _NonceCompact.default,
      era: _ExtrinsicEra.default
    }, ExtrinsicSignature.decodeExtrinsicSignature(value));
  }

  static decodeExtrinsicSignature(value) {
    if (!value) {
      return {
        // we always explicitly set the unsigned version
        version: BIT_VERSION | BIT_UNSIGNED
      };
    }

    const version = value[0]; // only decode the full Uint8Array if we have the signed indicator,
    // alternatively only return the version (default for others)

    return (version & BIT_SIGNED) === BIT_SIGNED ? value : {
      version
    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.isSigned ? super.encodedLength : 1;
  }
  /**
   * @description `true` if the signature is valid
   */


  get isSigned() {
    return (this.version & BIT_SIGNED) === BIT_SIGNED;
  }
  /**
   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
   */


  get era() {
    return this.get('era');
  }
  /**
   * @description The [[Nonce]] for the signature
   */


  get nonce() {
    return this.get('nonce');
  }
  /**
   * @description The actuall [[Signature]] hash
   */


  get signature() {
    return this.get('signature');
  }
  /**
   * @description The [[Address]] that signed
   */


  get signer() {
    return this.get('signer');
  }
  /**
   * @description The encoded version for the signature
   */


  get version() {
    // Version Information.
    // 1 byte: version information:
    // - 7 low bits: version identifier (should be 0b0000001).
    // - 1 high bit: signed flag: 1 if this is a transaction (e.g. contains a signature).
    return this.get('version').toNumber();
  }
  /**
   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
   */


  set era(era) {
    this.set('era', era);
  }

  injectSignature(signature, signer, nonce, era) {
    this.set('era', era);
    this.set('nonce', nonce);
    this.set('signer', signer);
    this.set('signature', signature);
    this.set('version', new _U.default(BIT_VERSION | BIT_SIGNED));
    return this;
  }
  /**
   * @description Adds a raw signature
   */


  addSignature(_signer, _signature, _nonce) {
    let _era = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : IMMORTAL_ERA;

    const signer = new _Address.default(_signer);
    const nonce = new _NonceCompact.default(_nonce);
    const era = new _ExtrinsicEra.default(_era);
    const signature = new _Signature.default(_signature);
    return this.injectSignature(signature, signer, nonce, era);
  }
  /**
   * @description Generate a payload and pplies the signature from a keypair
   */


  sign(method, account, _ref) {
    let {
      blockHash,
      era,
      nonce,
      version
    } = _ref;
    const signer = new _Address.default(account.publicKey);
    const signingPayload = new _SignaturePayload.default({
      nonce,
      method,
      era: era || this.era || IMMORTAL_ERA,
      blockHash
    });
    const signature = new _Signature.default(signingPayload.sign(account, version));
    return this.injectSignature(signature, signer, signingPayload.nonce, signingPayload.era);
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return this.isSigned ? super.toU8a(isBare) : new Uint8Array([this.version]);
  }

}

exports.default = ExtrinsicSignature;