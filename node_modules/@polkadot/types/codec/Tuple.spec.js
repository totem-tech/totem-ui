"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _static = _interopRequireDefault(require("@polkadot/extrinsics/static"));

var _Method = _interopRequireDefault(require("../primitive/Method"));

var _Text = _interopRequireDefault(require("../primitive/Text"));

var _U = _interopRequireDefault(require("../primitive/U32"));

var _BlockNumber = _interopRequireDefault(require("../type/BlockNumber"));

var _Proposal = _interopRequireDefault(require("../type/Proposal"));

var _VoteThreshold = _interopRequireDefault(require("../type/VoteThreshold"));

var _Tuple = _interopRequireDefault(require("./Tuple"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
describe('Tuple', () => {
  let tuple;
  beforeEach(() => {
    tuple = new _Tuple.default([_Text.default, _U.default], ['bazzing', 69]);
  });
  describe('decoding', () => {
    const testDecode = (type, input) => it("can decode from ".concat(type), () => {
      const t = new _Tuple.default([_Text.default, _U.default], input);
      expect(t.toJSON()).toEqual(['bazzing', 69]);
    });

    testDecode('array', ['bazzing', 69]);
    testDecode('hex', '0x1c62617a7a696e6745000000');
    testDecode('Uint8Array', Uint8Array.from([28, 98, 97, 122, 122, 105, 110, 103, 69, 0, 0, 0]));
  });
  describe('encoding', () => {
    const testEncode = (to, expected) => it("can encode ".concat(to), () => {
      expect(tuple[to]()).toEqual(expected);
    });

    testEncode('toHex', '0x1c62617a7a696e6745000000');
    testEncode('toJSON', ['bazzing', 69]);
    testEncode('toU8a', Uint8Array.from([28, 98, 97, 122, 122, 105, 110, 103, 69, 0, 0, 0]));
    testEncode('toString', '["bazzing",69]');
  });
  it.skip('creates properly via actual hex string', () => {
    _Method.default.injectMethods(_static.default);

    const test = new (_Tuple.default.with([_BlockNumber.default, _Proposal.default, _VoteThreshold.default]))('0x62190000000000000003507b0a092230783432223a202230783433220a7d0a01');
    expect(test[0].toNumber()).toEqual(6498);
    expect(test[1].callIndex).toEqual(new Uint8Array([0, 3]));
    expect(test[2].toNumber()).toEqual(1);
  });
  it('exposes the Types', () => {
    expect(tuple.Types).toEqual(['Text', 'U32']);
  });
  it('exposes the Types (object creation)', () => {
    const test = new _Tuple.default({
      BlockNumber: _BlockNumber.default,
      VoteThreshold: _VoteThreshold.default
    }, []);
    expect(test.Types).toEqual(['BlockNumber', 'VoteThreshold']);
  });
  it('exposes filter', () => {
    expect(tuple.filter(v => v.toJSON() === 69)).toEqual([new _U.default(69)]);
  });
  it('exposes map', () => {
    expect(tuple.map(v => v.toString())).toEqual(['bazzing', '69']);
  });
  describe('utils', () => {
    it('compares against inputs', () => {
      expect(tuple.eq(['bazzing', 69])).toBe(true);
    });
    it('compares against inputs (mismatch)', () => {
      expect(tuple.eq(['bazzing', 72])).toBe(false);
    });
  });
  describe('toRawType', () => {
    it('generates sane value with array types', () => {
      expect(new _Tuple.default([_U.default, _BlockNumber.default]).toRawType()).toEqual('(u32,u64)');
    });
    it('generates sane value with object types', () => {
      expect(new _Tuple.default({
        number: _U.default,
        blockNumber: _BlockNumber.default
      }).toRawType()).toEqual('(u32,u64)');
    });
  });
});