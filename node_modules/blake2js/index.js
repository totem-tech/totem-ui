const addon = require('bindings')('addon.node');
const debug = require('debug')('blake2');
const stream = require('readable-stream');
const assert = require('assert');
var util = require('util');
/* eslint no-var:0, prefer-arrow-callback:0, func-names:0, no-throw-literal:0 */
/* eslint prefer-template:0, prefer-rest-params:0, max-len:0, vars-on-top:0 */
/* eslint no-param-reassign:0, no-underscore-dangle:0, consistent-return:0 */

var classes = {};

exports.createHash = function (algorithm, options) {
	assert(typeof algorithm === 'string' && /^blake2\w{1,2}$/.test(algorithm),
		'Invalid or unspecified algorithm!');
	debug('Creating hash with:\nalgorithm: %s\noptions: %s',
		algorithm, JSON.stringify(options));
	return new classes[algorithm](options);
};

exports.hash = function (algorithm, data, options, resEncoding) {
	if (typeof data === 'string' || Buffer.isBuffer(data)) data = { raw: data };

	return exports.createHash(algorithm, options)
		.update(data.raw, data.encoding)
		.digest(resEncoding || 'hex');
};

exports.default = exports;

['blake2s', 'blake2sp', 'blake2b', 'blake2bp'].forEach(function (algorithm) {
	classes[algorithm] = function (options) {
		assert(!options || typeof options === 'object',
			'Options must be an object');
		debug('Received options: %s', JSON.stringify(options));

		var outlen = addon[algorithm].OUTBYTES;
		var encoding = 'utf-8';
		var key = null;

		if (options) {
			if (options.outlen) {
				assert(typeof options.outlen === 'number',
					'Outlen must be a number!');
				assert(options.outlen > 0 && options.outlen <= outlen,
					'Outlen must be a value between 1 and ' + outlen);

				outlen = options.outlen;
			}

			if (options.encoding) {
				assert(typeof options.encoding === 'string',
					'Encoding must be a string!');

				encoding = options.encoding;
			}

			if (options.key) {
				assert(typeof options.key === 'string' || Buffer.isBuffer(options.key),
					'Key must either be a Buffer or a string');

				key = Buffer.isBuffer(options.key)
				    ? options.key
				    : new Buffer(options.key, encoding);
			}
		}

		debug('Parsed options:\noutlen: %s\nkey: %s',
			outlen, key ? key.toString(encoding) : 'none');

		stream.Transform.call(this); // super

		var data = new Buffer(addon[algorithm].BUFFER_SIZE);

		if (key) addon[algorithm].init_key(data, outlen, key);
		else addon[algorithm].init(data, outlen);

		this.update = function (chunk, en) {
			en = en || 'utf-8';
			assert(chunk && (typeof chunk === 'string' || Buffer.isBuffer(chunk)),
				'Data is required and must be a Buffer (or a string)');
			assert(Buffer.isBuffer(chunk) || typeof en === 'string',
				'Encoding must be a string!');

			chunk = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk, en);
			addon[algorithm].update(data, chunk);

			return this;
		};

		this.digest = function (enc) {
			assert(!enc || typeof enc === 'string',
				'Encoding must be a string!');

			const result = addon[algorithm].final(data, outlen);
			return enc ? result.toString(enc) : result;
		};

		this._transform = function (chunk, enc, done) {
			this.update(chunk, enc); done();
		};

		this._flush = function (done) {
			this.push(this.digest()); done();
		};
	};

	util.inherits(classes[algorithm], stream.Transform);
});
