"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateArgs = validateArgs;
exports.validateDeploy = validateDeploy;
exports.validateMethods = validateMethods;
exports.validateAbi = validateAbi;
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _util = require("@polkadot/util");

var _Compact = _interopRequireDefault(require("./codec/Compact"));

var _createType = require("./codec/createType");

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function validateArgs(name, args) {
  (0, _util.assert)(Array.isArray(args), "Expected 'args' to exist on ".concat(name));
  args.forEach(arg => {
    const unknownKeys = Object.keys(arg).filter(key => !['name', 'type'].includes(key));
    (0, _util.assert)(unknownKeys.length === 0, "Unknown keys ".concat(unknownKeys.join(', '), " found in ABI args for ").concat(name));
    (0, _util.assert)((0, _util.isString)(arg.name), "".concat(name, " args should have valid name "));
    (0, _util.assert)((0, _util.isString)(arg.type) || (0, _util.isObject)(arg.type), "".concat(name, " args should have valid type"));
  });
}

function validateDeploy(_ref) {
  let {
    deploy
  } = _ref;
  const unknownKeys = Object.keys(deploy).filter(key => !['args'].includes(key));
  (0, _util.assert)(unknownKeys.length === 0, "Unknown keys ".concat(unknownKeys.join(', '), " found in ABI deploy"));
  validateArgs('deploy', deploy.args);
}

function validateMethods(_ref2) {
  let {
    messages
  } = _ref2;
  messages.forEach(method => {
    const unknownKeys = Object.keys(method).filter(key => !['args', 'mutates', 'name', 'selector', 'return_type'].includes(key));
    (0, _util.assert)(unknownKeys.length === 0, "Unknown keys ".concat(unknownKeys.join(', '), " found in ABI args for messages.").concat(method.name));
    (0, _util.assert)((0, _util.isString)(method.name), "Expected name for messages.".concat(method.name));
    (0, _util.assert)((0, _util.isNumber)(method.selector), "Expected selector for messages.".concat(method.name));
    (0, _util.assert)((0, _util.isNull)(method.return_type) || (0, _util.isString)(method.return_type) || (0, _util.isObject)(method.return_type), "Expected return_type for messages.".concat(method.name));
    validateArgs("messages.".concat(method.name), method.args);
  });
}

function validateAbi(abi) {
  const unknownKeys = Object.keys(abi).filter(key => !['deploy', 'messages', 'name'].includes(key));
  (0, _util.assert)(unknownKeys.length === 0, "Unknown fields ".concat(unknownKeys.join(', '), " found in ABI"));
  (0, _util.assert)(abi.deploy && abi.messages && (0, _util.isString)(abi.name), 'ABI should have deploy, messages & name sections');
  validateDeploy(abi);
  validateMethods(abi);
}

class ContractAbi {
  constructor(abi) {
    this.abi = void 0;
    this.deploy = void 0;
    this.messages = {};
    validateAbi(abi);
    this.abi = abi;
    this.deploy = this._createEncoded('deploy', abi.deploy);
    abi.messages.forEach(method => {
      const name = (0, _util.stringCamelCase)(method.name);
      this.messages[name] = this._createEncoded("messages.".concat(name), method);
    });
  }

  _convertType(type) {
    if ((0, _util.isString)(type)) {
      return type;
    } else if (Array.isArray(type)) {
      return "(".concat(type.map(type => this._convertType(type)).join(','), ")");
    } else if (type['Option<T>']) {
      return "Option<".concat(this._convertType(type['Option<T>'].T), ">");
    } else if (type['Result<T,E>']) {
      return "()"; // Result is not supported, but only applicable for returns
    } else if (type['Vec<T>']) {
      return "Vec<".concat(this._convertType(type['Vec<T>'].T), ">");
    } else if (type['[T;n]']) {
      return "[".concat(this._convertType(type['[T;n]'].T), ";").concat(type['[T;n]'].n, "]");
    }

    throw new Error("Unknown type specified ".concat(JSON.stringify(type)));
  }

  _createClazz(args, baseDef) {
    return (0, _createType.createClass)(JSON.stringify(args.reduce((base, _ref3) => {
      let {
        name,
        type
      } = _ref3;
      base[name] = type;
      return base;
    }, baseDef)));
  }

  _createEncoded(name, method) {
    const args = method.args.map((_ref4) => {
      let {
        name,
        type
      } = _ref4;
      return {
        name: (0, _util.stringCamelCase)(name),
        type: this._convertType(type)
      };
    });

    const Clazz = this._createClazz(args, (0, _util.isUndefined)(method.selector) ? {} : {
      __selector: 'u32'
    });

    const baseStruct = {
      __selector: method.selector
    };

    const encoder = function encoder() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }

      (0, _util.assert)(params.length === args.length, "Expected ".concat(args.length, " arguments to contract ").concat(name, ", found ").concat(params.length));
      const u8a = new Clazz(args.reduce((mapped, _ref5, index) => {
        let {
          name
        } = _ref5;
        mapped[name] = params[index];
        return mapped;
      }, (0, _objectSpread2.default)({}, baseStruct))).toU8a();
      return _Compact.default.addLengthPrefix(u8a);
    };

    const fn = encoder;
    fn.args = args;
    fn.isConstant = !(method.mutates || false);
    fn.type = method.return_type ? this._convertType(method.return_type) : null;
    return fn;
  }

}

exports.default = ContractAbi;