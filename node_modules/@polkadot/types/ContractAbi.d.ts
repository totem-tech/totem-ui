import { CodecArg } from './types';
export declare type ContractABITypes$Struct = {
    'Option<T>'?: {
        T: ContractABITypes;
    };
    'Result<T,E>'?: {
        T: ContractABITypes;
        E: ContractABITypes;
    };
    'Vec<T>'?: {
        T: ContractABITypes;
    };
    '[T;n]'?: {
        T: ContractABITypes;
        n: number;
    };
};
export declare type ContractABITypes = string | ContractABITypes$Struct | Array<string | ContractABITypes$Struct>;
export declare type ContractABIArg = {
    name: string;
    type: ContractABITypes;
};
export declare type ContractABIMethodBase = {
    args: Array<ContractABIArg>;
};
export declare type ContractABIMethod = ContractABIMethodBase & {
    mutates?: boolean;
    name: string;
    selector: number;
    return_type: ContractABITypes | null;
};
export declare type ContractABI = {
    deploy: ContractABIMethodBase;
    messages: Array<ContractABIMethod>;
    name: string;
};
export interface ContractABIFn$Arg {
    name: string;
    type: string;
}
export interface ContractABIFn {
    (...args: Array<CodecArg>): Uint8Array;
    args: Array<ContractABIFn$Arg>;
    isConstant: boolean;
    type: string | null;
}
export interface Contract {
    abi: ContractABI;
    deploy: ContractABIFn;
    messages: {
        [index: string]: ContractABIFn;
    };
}
export declare function validateArgs(name: string, args: Array<ContractABIArg>): void;
export declare function validateDeploy({ deploy }: ContractABI): void;
export declare function validateMethods({ messages }: ContractABI): void;
export declare function validateAbi(abi: ContractABI): void;
export default class ContractAbi implements Contract {
    abi: ContractABI;
    deploy: ContractABIFn;
    messages: {
        [index: string]: ContractABIFn;
    };
    constructor(abi: ContractABI);
    private _convertType;
    private _createClazz;
    private _createEncoded;
}
