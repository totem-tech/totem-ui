// import { Bond } from 'oo7'
import { addCodecTransform, calls, post, runtime, ss58Decode } from 'oo7-substrate'
import { isBond, isUint8Arr } from '../utils/utils'
import { hexToBytes } from '../utils/convert'

const validatedSenderAddress = address => runtime.indices.tryIndex(
    new Bond().defaultTo(ss58Decode(isBond(address) ? address._value : address))
)
const hashBytes = hash => {
    hash = isBond(hash) ? hash._value : hash
    hash = isUint8Arr(hash) ? hash : hexToBytes(hash)
    return hash
}

// addNewProject registers a hash against a wallet into the blockchain
//
// Params:
// @address string/Bond
// @hash    string: an unique hash generated by using project name, owner address and description
//
// Returns Bond : expected values from returned bond =>
//              1. {signing: true/false}
//              2. {sending: true/false}
//              3. 'ready'
//              4. {finalized: 'TXID'}
//              5. {failed: {code: xxx, message: 'error message'}}
export const addNewProject = (ownerAddress, hash) => {

    return post({
        sender: validatedSenderAddress(ownerAddress),
        call: calls.projects.addNewProject(hashBytes(hash)),
        compact: false,
        longevity: true
    })
}

// ownerProjectsList retrieves a list of project hashes owned by @address
//
// Returns Bond
export const ownerProjectsList = address => {
    return runtime.projects.ownerProjectsList(ss58Decode(address))
}

//
export const projectHashStatus = hash => {
    return runtime.projects.projectHashStatus(hashBytes(hash))
}

// reassignProject transfers ownership of a project to a new owner address 
//
// Params:
// @ownerAddress    string/Bond: current owner of the project
// @newOwnerAddress string/Bond: address which will be the new owner
// @hash            string     : unique hash/ID of the project
//
// Returns Bond : expected values from returned bond =>
//              1. {signing: true/false}
//              2. {sending: true/false}
//              3. 'ready'
//              4. {finalized: 'TXID'}
//              5. {failed: {code: xxx, message: 'error message'}}
export const reassignProject = (ownerAddress, newOwnerAddress, hash) => {
    return post({
        sender: validatedSenderAddress(ownerAddress),
        call: calls.projects.reassignProject(newOwnerAddress, hashBytes(hash)),
        compact: false,
        longevity: true
    })
}

// removeProject removes project
//
// Params:
// @ownerAddress    string/Bond: current owner of the project
// @hash            string     : unique hash/ID of the project
//
// Returns Bond : expected values from returned bond =>
//              1. {signing: true/false}
//              2. {sending: true/false}
//              3. 'ready'
//              4. {finalized: 'TXID'}
//              5. {failed: {code: xxx, message: 'error message'}}
export const removeProject = (ownerAddress, hash) => {
    return post({
        sender: validatedSenderAddress(ownerAddress),
        call: calls.projects.removeProject(hashBytes(hash)),
        compact: false,
        longevity: true
    })
}

// closeProject removes project
//
// Params:
// @ownerAddress    string/Bond: current owner of the project
// @hash            string     : unique hash/ID of the project
//
// Returns Bond : expected values from returned bond =>
//              1. {signing: true/false}
//              2. {sending: true/false}
//              3. 'ready'
//              4. {finalized: 'TXID'}
//              5. {failed: {code: xxx, message: 'error message'}}
export const closeProject = (ownerAddress, hash) => {
    return post({
        sender: validatedSenderAddress(ownerAddress),
        call: calls.projects.closeProject(hashBytes(hash)),
        compact: false,
        longevity: true
    })
}

// reopenProject removes project
//
// Params:
// @ownerAddress    string/Bond: current owner of the project
// @hash            string     : unique hash/ID of the project
//
// Returns Bond : expected values from returned bond =>
//              1. {signing: true/false}
//              2. {sending: true/false}
//              3. 'ready'
//              4. {finalized: 'TXID'}
//              5. {failed: {code: xxx, message: 'error message'}}
export const reopenProject = (ownerAddress, hash) => {
    return post({
        sender: validatedSenderAddress(ownerAddress),
        call: calls.projects.reopenProject(hashBytes(hash)),
        compact: false,
        longevity: true
    })
}

export const project = {
    add: addNewProject,
    close: closeProject,
    listByOwner: ownerProjectsList,
    reassign: reassignProject,
    remove: removeProject,
    reopen: reopenProject,
    status: projectHashStatus,
}

export const timeKeeping = {
    record: {
        // Blockchain transaction
        // @postingPeriod u16: 15 fiscal periods (0-14) // not yet implemented use default 0
        add: (workerAddress, projectHash, recordHash, blockCount, postingPeriod, blockStart, blockEnd) => {
            return post({
                sender: validatedSenderAddress(workerAddress),
                call: calls.timekeeping.submitTime(
                    hashBytes(projectHash),
                    hashBytes(recordHash),
                    blockCount,
                    postingPeriod,
                    blockStart,
                    blockEnd,
                ),
                compact: false,
                longevity: true
            })
        },
        // Blockchain transaction
        // (project owner) approve a time record
        approve: (ownerAddress, projectHash, workerAddress, recordHash, status, locked, reason) => {
            return post({
                sender: validatedSenderAddress(ownerAddress),
                call: calls.timekeeping.authoriseTime(
                    hashBytes(projectHash),
                    validatedSenderAddress(ownerAddress),
                    validatedSenderAddress(workerAddress),
                    hashBytes(recordHash),
                    status,
                    locked,
                    reason,
                ),
                compact: false,
                longevity: true
            })
        },
        // get details of a record
        get: (recordHash) => runtime.timekeeping.timeRecord(hashBytes(recordHash)),
        // list of all record hashes booked by worker
        list: workerAddress => runtime.timekeeping.workerTimeRecordsHashList(ss58Decode(workerAddress)),
        // list of all record hashes in a project 
        listByProject: projectHash => runtime.timekeeping.projectTimeRecordsHashList(hashBytes(projectHash)),
    },
    invitation: {
        // Blockchain transaction
        // (worker) accept invitation to a project
        accept: (projectHash, workerAddress, accepted) => {
            return post({
                sender: validatedSenderAddress(workerAddress),
                call: calls.timekeeping.workerAcceptanceProject(hashBytes(projectHash), accepted),
                compact: false,
                longevity: true
            })
        },
        // Blockchain transaction
        // (project owner) invite a worker to join a project
        add: (projectHash, ownerAddress, workerAddress) => {
            return post({
                sender: validatedSenderAddress(ownerAddress),
                call: calls.timekeeping.notifyProjectWorker(
                    ss58Decode(workerAddress),
                    hashBytes(projectHash),
                ),
                compact: false,
                longevity: true
            })
        },
        // status of an invitation
        status: (projectHash, workerAddress) => runtime.timekeeping.workerProjectsBacklogStatus([
            hashBytes(projectHash),
            ss58Decode(workerAddress)
        ]),
        listByProject: projectHash => runtime.timekeeping.projectWorkersList(hashBytes(projectHash)),
        // projects that worker has been invited to or accepted
        listByWorker: workerAddress => runtime.timekeeping.workerProjectsBacklogList(ss58Decode(workerAddress)),
    },
    // list of workers that accepted invitation
    workers: projectHash => runtime.timekeeping.projectWorkersList(hashBytes(projectHash)),
    // check if worker is banned. undefined: not banned, object: banned
    workerBanStatus: (projectHash, address) => runtime.timekeeping.projectWorkersBanList(
        hashBytes(projectHash),
        validatedSenderAddress(address)
    ),
}

// Include all functions here that will be used by Queue Service
// Only blockchain transactions
export default {
    addNewProject,
    reassignProject,
    removeProject,
    closeProject,
    reopenProject,
    timeKeeping_invitation_accept: timeKeeping.invitation.accept,
    timeKeeping_invitation_add: timeKeeping.invitation.add,
    timeKeeping_record_add: timeKeeping.record.add,
    timeKeeping_record_approve: timeKeeping.record.approve,
}

// ToDo: use common-utils library
const types = {
    "ProjectHash": "Hash",
    "DeletedProject": "Hash",
    "ProjectStatus": "u16",
    "AcceptAssignedStatus": "bool",
    "BanStatus": "bool",
    "LockStatus": "bool",
    "ReasonCode": "u16",
    "ReasonCodeType": "u16",
    "NumberOfBlocks": "u64",
    "PostingPeriod": "u16",
    "ProjectHashRef": "Hash",
    "StartOrEndBlockNumber": "u64",
    "StatusOfTimeRecord": "u16",
    "ReasonCodeStruct": {
        "ReasonCodeKey": "ReasonCode",
        "ReasonCodeTypeKey": "ReasonCodeType"
    },
    "ReasonCodeStruct<ReasonCode,ReasonCodeType>": "ReasonCodeStruct",
    "BannedStruct": {
        "BanStatusKey": "BanStatus",
        "ReasonCodeStructKey": "ReasonCodeStruct"
    },
    "BannedStruct<BanStatus,ReasonCodeStruct>": "BannedStruct",
    "Timekeeper": {
        "worker": "AccountId",
        "project_hash": "ProjectHashRef",
        "total_blocks": "NumberOfBlocks",
        "locked_status": "LockStatus",
        "submit_status": "StatusOfTimeRecord",
        "reason_code": "ReasonCodeStruct",
        "posting_period": "PostingPeriod",
        "start_block": "StartOrEndBlockNumber",
    },
    "Timekeeper<AccountId,ProjectHashRef,NumberOfBlocks,LockStatus,\nStatusOfTimeRecord,ReasonCodeStruct,PostingPeriod,StartOrEndBlockNumber>": "Timekeeper",
}
Object.keys(types).forEach(key => addCodecTransform(key, types[key]))