"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFunction;

var _types = require("@polkadot/types");

var _Storage = require("@polkadot/types/Metadata/v5/Storage");

var _util = require("@polkadot/util");

var _getHasher = _interopRequireDefault(require("./getHasher"));

// Copyright 2017-2019 @polkadot/storage authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

/**
 * From the schema of a function in the module's storage, generate the function
 * that will return the correct storage key.
 *
 * @param schema - The function's definition schema to create the function from.
 * The schema is taken from state_getMetadata.
 * @param options - Additional options when creating the function. These options
 * are not known at runtime (from state_getMetadata), they need to be supplied
 * by us manually at compile time.
 */
function createFunction(section, method, meta) {
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const stringKey = options.key ? options.key : "".concat(section.toString(), " ").concat(method.toString());
  const rawKey = (0, _util.stringToU8a)(stringKey); // Get the hashing function

  let hasher;
  let key2Hasher;

  if (meta.type.isDoubleMap) {
    hasher = (0, _getHasher.default)(meta.type.asDoubleMap.hasher);
    key2Hasher = (0, _getHasher.default)(meta.type.asDoubleMap.key2Hasher);
  } else if (meta.type.isMap) {
    hasher = (0, _getHasher.default)(meta.type.asMap.hasher);
  } else {
    hasher = (0, _getHasher.default)();
  } // Can only have zero or one argument:
  // - storage.balances.freeBalance(address)
  // - storage.timestamp.blockPeriod()


  const storageFn = arg => {
    let key = rawKey;

    if (meta.type.isDoubleMap) {
      (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) && !(0, _util.isUndefined)(arg[0]) && !(0, _util.isNull)(arg[0]) && !(0, _util.isUndefined)(arg[1]) && !(0, _util.isNull)(arg[1]), "".concat(meta.name, " expects two arguments"));
      const type1 = meta.type.asDoubleMap.key1.toString();
      const type2 = meta.type.asDoubleMap.key2.toString();
      const param1Encoded = (0, _util.u8aConcat)(key, (0, _types.createType)(type1, arg[0]).toU8a(true));
      const param1Hashed = hasher(param1Encoded);
      const param2Hashed = key2Hasher((0, _types.createType)(type2, arg[1]).toU8a(true));
      return _types.Compact.addLengthPrefix((0, _util.u8aConcat)(param1Hashed, param2Hashed));
    }

    if (meta.type.isMap) {
      (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), "".concat(meta.name, " expects one argument"));
      const type = meta.type.asMap.key.toString();
      const param = (0, _types.createType)(type, arg).toU8a();
      key = (0, _util.u8aConcat)(key, param);
    } // StorageKey is a Bytes, so is length-prefixed


    return _types.Compact.addLengthPrefix(options.skipHashing ? key : hasher(key));
  };

  if (meta.type.isMap && meta.type.asMap.isLinked) {
    const keyHash = new _types.U8a(hasher("head of ".concat(stringKey)));

    const keyFn = () => keyHash;

    keyFn.meta = new _Storage.StorageFunctionMetadata({
      name: meta.name,
      modifier: new _Storage.StorageFunctionModifier('Required'),
      type: new _Storage.StorageFunctionType(new _Storage.PlainType(meta.type.asMap.key), 0),
      fallback: new _types.Bytes(),
      documentation: meta.documentation
    });
    storageFn.headKey = new _types.StorageKey(keyFn);
  }

  storageFn.meta = meta;
  storageFn.method = (0, _util.stringLowerFirst)(method.toString());
  storageFn.section = (0, _util.stringLowerFirst)(section.toString());

  storageFn.toJSON = () => meta.toJSON();

  return storageFn;
}