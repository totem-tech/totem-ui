"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateTypes;

var _util = require("@polkadot/util");

var _createType = require("../../codec/createType");

var _flattenUniq = _interopRequireDefault(require("./flattenUniq"));

var _codec = require("../../codec");

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function validateTypes(types, throwError) {
  const extractTypes = types => {
    return types.map(type => {
      const decoded = (0, _createType.getTypeDef)(type);

      switch (decoded.info) {
        case _createType.TypeDefInfo.Plain:
          return decoded.type;

        case _createType.TypeDefInfo.Compact:
        case _createType.TypeDefInfo.Option:
        case _createType.TypeDefInfo.Vector:
          return extractTypes([decoded.sub.type]);

        case _createType.TypeDefInfo.Tuple:
          return extractTypes(decoded.sub.map(sub => sub.type));

        default:
          throw new Error('Unreachable');
      }
    });
  };

  const typeRegistry = (0, _codec.getTypeRegistry)();
  const missing = (0, _flattenUniq.default)(extractTypes(types)).filter(type => (0, _util.isUndefined)(typeRegistry.get(type)));

  if (missing.length !== 0) {
    const message = "Unknown types found, no types for ".concat(missing);

    if (throwError) {
      throw new Error(message);
    } else {
      console.error(message);
    }
  }
}