import { StorageFunctionMetadata as MetaV5 } from '../Metadata/v5/Storage';
import { AnyU8a } from '../types';
import Bytes from './Bytes';
export interface StorageFunction {
    (arg?: any): Uint8Array;
    headKey?: Uint8Array;
    meta: MetaV5;
    method: string;
    section: string;
    toJSON: () => any;
}
declare type Decoded = {
    key?: Uint8Array | string;
    method?: string;
    section?: string;
};
/**
 * @name StorageKey
 * @description
 * A representation of a storage key (typically hashed) in the system. It can be
 * constructed by passing in a raw key or a StorageFunction with (optional) arguments.
 */
export default class StorageKey extends Bytes {
    private _meta?;
    private _method?;
    private _outputType?;
    private _section?;
    constructor(value?: AnyU8a | StorageKey | StorageFunction | [StorageFunction, any]);
    static decodeStorageKey(value?: AnyU8a | StorageKey | StorageFunction | [StorageFunction, any]): Decoded;
    static getMeta(value: StorageKey | StorageFunction | [StorageFunction, any]): MetaV5 | undefined;
    static getType(value: StorageKey | StorageFunction | [StorageFunction, any]): string | undefined;
    /**
     * @description The metadata or `undefined` when not available
     */
    readonly meta: MetaV5 | undefined;
    /**
     * @description The key method or `undefined` when not specified
     */
    readonly method: string | undefined;
    /**
     * @description The output type, `null` when not available
     */
    readonly outputType: string | undefined;
    /**
     * @description The key section or `undefined` when not specified
     */
    readonly section: string | undefined;
}
export {};
