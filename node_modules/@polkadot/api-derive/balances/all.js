"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

var _idAndIndex = require("../accounts/idAndIndex");

var _drr = require("../util/drr");

// Copyright 2017-2019 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const EMPTY_ACCOUNT = new _types.AccountId();
const ZERO = new _types.Balance(0);

function calcBalances(_ref) {
  let [accountId = EMPTY_ACCOUNT, bestNumber = ZERO, [freeBalance = ZERO, reservedBalance = ZERO, locks = [], vesting = new _types.Option(_types.VestingSchedule, null), accountNonce = ZERO]] = _ref;
  let lockedBalance = ZERO;

  if (Array.isArray(locks)) {
    // only get the locks that are valid until passed the current block
    const totals = locks.filter(value => bestNumber && value.until.gt(bestNumber)); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699

    lockedBalance = totals[0] ? (0, _util.bnMax)(...totals.map((_ref2) => {
      let {
        amount
      } = _ref2;
      return amount;
    })) : ZERO;
  } // offset = balance locked at genesis, perBlock is the unlock amount


  const {
    offset,
    perBlock
  } = vesting.unwrapOr(new _types.VestingSchedule());
  const vestedNow = perBlock.mul(bestNumber);
  const vestedBalance = vestedNow.gt(offset) ? freeBalance : freeBalance.sub(offset).add(vestedNow); // NOTE Workaround for this account on Alex (one of a couple reported) -
  //   5F7BJL6Z4m8RLtK7nXEqqpEqhBbd535Z3CZeYF6ccvaQAY6N
  // The locked is > the vested and ended up with the locked > free,
  // i.e. related to https://github.com/paritytech/polkadot/issues/225
  // (most probably due to movements from stash -> controller -> free)

  const availableBalance = (0, _util.bnMax)(ZERO, vestedBalance.sub(lockedBalance));
  return new _types.StructAny({
    accountId,
    accountNonce,
    availableBalance,
    freeBalance,
    lockedBalance,
    reservedBalance,
    vestedBalance,
    votingBalance: freeBalance.add(reservedBalance)
  });
}
/**
 * @name all
 * @param {( ccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the combined results of the storage queries for
 * all relevant fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ([accountId, lockedBalance]) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function all(api) {
  return address => {
    return (0, _idAndIndex.idAndIndex)(api)(address).pipe((0, _operators.switchMap)((_ref3) => {
      let [accountId] = _ref3;
      return accountId ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(accountId), api.derive.chain.bestNumber(), api.queryMulti([[api.query.balances.freeBalance, accountId], [api.query.balances.reservedBalance, accountId], [api.query.balances.locks, accountId], [api.query.balances.vesting, accountId], [api.query.system.accountNonce, accountId]])]) : (0, _rxjs.of)([undefined, undefined, [undefined, undefined, undefined, undefined, undefined]]);
    }), (0, _operators.map)(calcBalances), (0, _drr.drr)());
  };
}