import { AnyNumber, AnyU8a, IKeyringPair } from '../types';
import Struct from '../codec/Struct';
import Hash from '../primitive/Hash';
import Method from '../primitive/Method';
import RuntimeVersion from '../rpc/RuntimeVersion';
import ExtrinsicEra from './ExtrinsicEra';
import Nonce from './NonceCompact';
declare type SignaturePayloadValue = {
    nonce?: AnyNumber;
    method?: Method;
    era?: AnyU8a | ExtrinsicEra;
    blockHash?: AnyU8a;
};
/**
 * @name SignaturePayload
 * @description
 * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based
 * on the contents included
 *
 *   8 bytes: The Transaction Index/Nonce as provided in the transaction itself.
 *   2+ bytes: The Function Descriptor as provided in the transaction itself.
 *   2 bytes: The Transaction Era as provided in the transaction itself.
 *   32 bytes: The hash of the authoring block implied by the Transaction Era and the current block.
 */
export default class SignaturePayload extends Struct {
    protected _signature?: Uint8Array;
    constructor(value?: SignaturePayloadValue | Uint8Array);
    /**
     * @description `true` if the payload refers to a valid signature
     */
    readonly isSigned: boolean;
    /**
     * @description The block [[Hash]] the signature applies to (mortal/immortal)
     */
    readonly blockHash: Hash;
    /**
     * @description The [[Method]] contained in the payload
     */
    readonly method: Method;
    /**
     * @description The [[ExtrinsicEra]]
     */
    readonly era: ExtrinsicEra;
    /**
     * @description The [[Nonce]]
     */
    readonly nonce: Nonce;
    /**
     * @description The raw signature as a `Uint8Array`
     */
    readonly signature: Uint8Array;
    /**
     * @description Sign the payload with the keypair
     */
    sign(signerPair: IKeyringPair, version?: RuntimeVersion): Uint8Array;
}
/**
 * @name SignaturePayloadRaw
 * @description
 * A version of [[SignaturePayload]] where it does not rely on [[Method]] being initalized with metadata. When constructing, it treats the [[Method]] as a raw stream of bytes, so will always apply the signature over this without any additional checking. Unlike the [[SignaturePayload]], it assumed that you will only construct and sign, thereby providing no insigt into constructed values
 */
export declare class SignaturePayloadRaw extends Struct {
    constructor(value?: any);
    /**
     * @description Sign the payload with the keypair
     */
    sign(signerPair: IKeyringPair): Uint8Array;
}
export {};
