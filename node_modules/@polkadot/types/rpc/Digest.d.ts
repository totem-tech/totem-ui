import BN from 'bn.js';
import Enum from '../codec/Enum';
import Struct from '../codec/Struct';
import Tuple from '../codec/Tuple';
import Vector from '../codec/Vector';
import Bytes from '../primitive/Bytes';
import Hash from '../primitive/Hash';
import U32 from '../primitive/U32';
import U64 from '../primitive/U64';
import AuthorityId from '../type/AuthorityId';
import Signature from '../type/Signature';
declare const CID_AURA = 1634891105;
declare const CID_BABE = 1700946274;
declare const CID_GRPA = 828860001;
export { CID_AURA, CID_BABE, CID_GRPA };
declare const AuthoritiesChange_base: import("../types").Constructor<Vector<AuthorityId>>;
/**
 * @name AuthoritiesChange
 * @description
 * Log for Authories changed
 */
export declare class AuthoritiesChange extends AuthoritiesChange_base {
}
/**
 * @name ChangesTrieRoot
 * @description
 * Log for changes to the Trie root
 */
export declare class ChangesTrieRoot extends Hash {
}
/**
 * @name ConsensusEngineId
 * @description
 * A 4-byte identifier (actually a [u8; 4]) identifying the engine, e.g. for Aura it would be [b'a', b'u', b'r', b'a']
 */
export declare class ConsensusEngineId extends U32 {
    static idToString(input: number | BN): string;
    static stringToId(input: string): number;
    /**
     * @description `true` if the engine matches aura
     */
    readonly isAura: boolean;
    /**
     * @description `true` is the engine matches babe
     */
    readonly isBabe: boolean;
    /**
     * @description `true` is the engine matches grandpa
     */
    readonly isGrandpa: boolean;
    /**
     * @description From the input bytes, decode into an aura-tuple
     */
    extractSlot(bytes: Bytes): U64;
    /**
     * @description Override the default toString to return a 4-byte string
     */
    toString(): string;
}
/**
 * @name Consensus
 * @description
 * Log item indicating consensus
 */
export declare class Consensus extends Tuple {
    constructor(value: any);
    /**
     * @description The wrapped engine [[ConsensusEngineId]]
     */
    readonly engine: ConsensusEngineId;
    /**
     * @description The wrapped [[Bytes]]
     */
    readonly data: Bytes;
    /**
     * @description The slot extracted from the raw data (fails on non-Aura)
     */
    readonly slot: U64;
}
/**
 * @name SealV0
 * @description
 * Log item indicating a sealing event. This has been replaced in later versions with a renamed [[Seal]], we however have kept compatibility with the old version
 */
export declare class SealV0 extends Tuple {
    constructor(value: any);
    /**
     * @description The wrapped [[Signature]]
     */
    readonly signature: Signature;
    /**
     * @description The wrapped [[U64]] slot
     */
    readonly slot: U64;
}
/**
 * @name Seal
 * @description
 * Log item indicating a sealing event.
 */
export declare class Seal extends Tuple {
    constructor(value: any);
    /**
     * @description The wrapped [[Signature]]
     */
    readonly signature: Signature;
    /**
     * @description The wrapped [[U64]] slot
     */
    readonly slot: U64;
}
/**
 * @name Other
 * @description
 * Log item that is just a stream of [[Bytes]]
 */
export declare class Other extends Bytes {
}
/**
 * @name PreRuntime
 * @description
 * These are messages from the consensus engine to the runtime, although the consensus engine the consensus engine can (and should) read them itself to avoid ode and state duplication.
 */
export declare class PreRuntime extends Tuple {
    constructor(value: any);
    /**
     * @description The wrapped [[ConsensusEngineId]]
     */
    readonly engine: ConsensusEngineId;
    /**
     * @description The wrapped [[Bytes]]
     */
    readonly data: Bytes;
    /**
     * @description The slot extracted from the raw data (fails on non-Aura)
     */
    readonly slot: U64;
}
declare const DigestItemEnumMap: {
    Other: typeof Other;
    AuthoritiesChange: typeof AuthoritiesChange;
    ChangesTrieRoot: typeof ChangesTrieRoot;
    SealV0: typeof SealV0;
    Consensus: typeof Consensus;
    Seal: typeof Seal;
    PreRuntime: typeof PreRuntime;
};
declare type DigestItemTypes = keyof typeof DigestItemEnumMap;
/**
 * @name DigestItem
 * @description
 * A [[Enum]] the specifies the specific item in the logs of a [[Digest]]
 */
export declare class DigestItem extends Enum {
    constructor(value: any);
    /**
     * @description Returns the item as a [[AuthoritiesChange]]
     */
    readonly asAuthoritiesChange: AuthoritiesChange;
    /**
     * @description Returns the item as a [[ChangesTrieRoot]]
     */
    readonly asChangesTrieRoot: ChangesTrieRoot;
    /**
     * @desciption Retuns the item as a [[Consensus]]
     */
    readonly asConsensus: Consensus;
    /**
     * @description Returns the item as a [[Other]]
     */
    readonly asOther: Other;
    /**
     * @description Returns the item as a [[PreRuntime]]
     */
    readonly asPreRuntime: PreRuntime;
    /**
     * @description Returns the item as a [[Seal]]
     */
    readonly asSeal: Seal;
    /**
     * @description Returns the item as a [[SealV0]]
     */
    readonly asSealV0: SealV0;
    /**
     * @description Returns true on [[AuthoritiesChange]]
     */
    readonly isAuthoritiesChange: boolean;
    /**
     * @description Returns true on [[ChangesTrieRoot]]
     */
    readonly isChangesTrieRoot: boolean;
    /**
     * @description Returns true on [[Consensus]]
     */
    readonly isConsensus: boolean;
    /**
     * @description Returns true on [[Other]]
     */
    readonly isOther: boolean;
    /**
     * @description Returns true on [[PreRuntime]]
     */
    readonly isPreRuntime: boolean;
    /**
     * @description Returns true on [[Seal]]
     */
    readonly isSeal: boolean;
    /**
     * @description Returns true on [[SealV0]]
     */
    readonly isSealV0: boolean;
    /**
     * @description Converts the Object to JSON, typically used for RPC transfers. For logs, we overrides to produce the hex version (sligning with substrate gives in actual JSON responses)
     */
    toJSON(): any;
    /**
     * @description Returns the type of engine, we just override here to get the typings correct
     */
    readonly type: DigestItemTypes;
}
/**
 * @name Digest
 * @description
 * A [[Header]] Digest
 */
export default class Digest extends Struct {
    constructor(value: any);
    /**
     * @description The [[DigestItem]] logs
     */
    readonly logs: Vector<DigestItem>;
    /**
     * @description The [[DigestItem]] logs, filtered, filter items included. This is useful for derive functionality where only a certain type of log is to be returned.
     */
    logsWith(...include: Array<DigestItemTypes>): Vector<DigestItem>;
    /**
     * @description The [[DigestItem]] logs, filtered, filter items exluded. This is useful for stripping headers for eg. WASM runtime execution.
     */
    logsWithout(...exclude: Array<DigestItemTypes>): Vector<DigestItem>;
}
