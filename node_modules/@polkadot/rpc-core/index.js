"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jsonrpc = _interopRequireDefault(require("@polkadot/jsonrpc"));

var _rpcProvider = require("@polkadot/rpc-provider");

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

// Copyright 2017-2019 @polkadot/rpc-core authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const l = (0, _util.logger)('rpc-core');
const EMPTY_META = {
  fallback: undefined,
  modifier: {
    isOptional: true
  },
  type: {
    asMap: {
      isLinked: false
    },
    isMap: false
  }
};
/**
 * @name Rpc
 * @summary The API may use a HTTP or WebSockets provider.
 * @description It allows for querying a Polkadot Client Node.
 * WebSockets provider is recommended since HTTP provider only supports basic querying.
 *
 * ```mermaid
 * graph LR;
 *   A[Api] --> |WebSockets| B[WsProvider];
 *   B --> |endpoint| C[ws://127.0.0.1:9944]
 * ```
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/rpc-core';
 * import WsProvider from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const api = new Api(provider);
 * ```
 */

class Rpc {
  /**
   * @constructor
   * Default constructor for the Api Object
   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket
   */
  constructor() {
    let provider = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _rpcProvider.WsProvider();
    this._provider = void 0;
    this.author = void 0;
    this.chain = void 0;
    this.state = void 0;
    this.system = void 0;
    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');
    this._provider = provider;
    this.author = this.createInterface(_jsonrpc.default.author);
    this.chain = this.createInterface(_jsonrpc.default.chain);
    this.state = this.createInterface(_jsonrpc.default.state);
    this.system = this.createInterface(_jsonrpc.default.system);
  }
  /**
   * @name signature
   * @summary Returns a string representation of the method with inputs and outputs.
   * @description
   * Formats the name, inputs and outputs into a human-readable string. This contains the input parameter names input types and output type.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/rpc-core';
   *
   * Api.signature({ name: 'test_method', params: [ { name: 'dest', type: 'Address' } ], type: 'Address' }); // => test_method (dest: Address): Address
   * ```
   */


  static signature(_ref) {
    let {
      method,
      params,
      type
    } = _ref;
    const inputs = params.map((_ref2) => {
      let {
        name,
        type
      } = _ref2;
      return "".concat(name, ": ").concat(type);
    }).join(', ');
    return "".concat(method, " (").concat(inputs, "): ").concat(type);
  }
  /**
   * @description Manually disconnect from the attached provider
   */


  disconnect() {
    this._provider.disconnect();
  }

  createInterface(_ref3) {
    let {
      methods
    } = _ref3;
    return Object.keys(methods).reduce((exposed, method) => {
      const def = methods[method];
      exposed[method] = def.isSubscription ? this.createMethodSubscribe(def) : this.createMethodSend(def);
      return exposed;
    }, {});
  }

  createMethodSend(method) {
    var _this = this;

    const rpcName = "".concat(method.section, "_").concat(method.method);

    const call = async function call() {
      // TODO Warn on deprecated methods
      try {
        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        const params = _this.formatInputs(method, values);

        const paramsJson = params.map(param => param.toJSON());
        const result = await _this._provider.send(rpcName, paramsJson);
        return _this.formatOutput(method, params, result);
      } catch (error) {
        const message = "".concat(Rpc.signature(method), ":: ").concat(error.message);
        l.error(message);
        throw new _util.ExtError(message, error.code, undefined);
      }
    };

    return call;
  }

  createMethodSubscribe(method) {
    var _this2 = this;

    const [updateType, subMethod, unsubMethod] = method.pubsub;
    const subName = "".concat(method.section, "_").concat(subMethod);
    const unsubName = "".concat(method.section, "_").concat(unsubMethod);
    const subType = "".concat(method.section, "_").concat(updateType);

    const unsubscribe = subscriptionId => this._provider.unsubscribe(subType, unsubName, subscriptionId);

    const _call = async function _call() {
      try {
        for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          values[_key2] = arguments[_key2];
        }

        const cb = values.pop();
        (0, _util.assert)((0, _util.isFunction)(cb), "Expected callback in last position of params");

        const params = _this2.formatInputs(method, values);

        const paramsJson = params.map(param => param.toJSON());

        const update = (error, result) => {
          if (error) {
            l.error("".concat(Rpc.signature(method), ":: ").concat(error.message));
            return;
          }

          cb(_this2.formatOutput(method, params, result));
        };

        return _this2._provider.subscribe(subType, subName, paramsJson, update);
      } catch (error) {
        const message = "".concat(Rpc.signature(method), ":: ").concat(error.message);
        l.error(message);
        throw new _util.ExtError(message, error.code, undefined);
      }
    };

    const call = _call;
    call.unsubscribe = unsubscribe;
    return call;
  }

  formatInputs(method, inputs) {
    const reqArgCount = method.params.filter((_ref4) => {
      let {
        isOptional
      } = _ref4;
      return !isOptional;
    }).length;
    const optText = reqArgCount === method.params.length ? '' : " (".concat(method.params.length - reqArgCount, " optional)");
    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= method.params.length, "Expected ".concat(method.params.length, " parameters").concat(optText, ", ").concat(inputs.length, " found instead"));
    return inputs.map((input, index) => (0, _types.createType)(method.params[index].type, input));
  }

  formatOutput(method, params, result) {
    const base = (0, _types.createType)(method.type, result);

    if (method.type === 'StorageData') {
      const key = params[0];

      try {
        return this.formatStorageData(key, base, (0, _util.isNull)(result));
      } catch (error) {
        console.error("Unable to decode storage ".concat(key.section, ".").concat(key.method, ":"), error.message);
        throw error;
      }
    } else if (method.type === 'StorageChangeSet') {
      // multiple return values (via state.storage subscription), decode the values
      // one at a time, all based on the query types. Three values can be returned -
      //   - Base - There is a valid value, non-empty
      //   - null - The storage key is empty (but in the resultset)
      //   - undefined - The storage value is not in the resultset
      return params[0].reduce((results, key) => {
        try {
          results.push(this.formatStorageSet(key, base));
        } catch (error) {
          console.error("Unable to decode storage ".concat(key.section, ".").concat(key.method, ":"), error.message);
          throw error;
        }

        return results;
      }, []);
    }

    return base;
  }

  formatStorageData(key, base, isNull) {
    // single return value (via state.getStorage), decode the value based on the
    // outputType that we have specified. Fallback to Data on nothing
    const type = key.outputType || 'Data';
    const meta = key.meta || EMPTY_META;

    if (meta.type.isMap && meta.type.asMap.isLinked) {
      return (0, _types.createType)(type, base, true);
    } else if (meta.modifier.isOptional) {
      return new _types.Option((0, _types.createClass)(type), isNull ? null : (0, _types.createType)(type, base, true));
    }

    return (0, _types.createType)(type, isNull ? meta.fallback : base, true);
  }

  formatStorageSet(key, base) {
    // Fallback to Data (i.e. just the encoding) if we don't have a specific type
    const type = key.outputType || 'Data'; // see if we have a result value for this specific key

    const hexKey = key.toHex();
    const {
      value
    } = base.changes.find(item => item.key.toHex() === hexKey) || {
      value: null
    };
    const meta = key.meta || EMPTY_META;

    if (!value) {
      return;
    } else if (meta.type.isMap && meta.type.asMap.isLinked) {
      return (0, _types.createType)(type, value.unwrapOr(null), true);
    } else if (meta.modifier.isOptional) {
      return new _types.Option((0, _types.createClass)(type), value.isNone ? null : (0, _types.createType)(type, value.unwrap(), true));
    }

    return (0, _types.createType)(type, value.unwrapOr(meta.fallback), true);
  }

}

exports.default = Rpc;